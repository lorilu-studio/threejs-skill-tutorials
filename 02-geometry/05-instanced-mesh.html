<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>示例5：InstancedMesh实例化</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background-color: #000;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #stats {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">示例5：InstancedMesh实例化 - 高效渲染大量相同物体</div>
    <div id="stats">
        <div>实例数量: <span id="count">0</span></div>
        <div>FPS: <span id="fps">0</span></div>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // 创建场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        // 创建相机
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 15, 25);
        camera.lookAt(0, 0, 0);

        // 创建渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // 创建网格辅助线
        const gridHelper = new THREE.GridHelper(50, 50);
        scene.add(gridHelper);

        // InstancedMesh - 实例化网格
        // 用于高效渲染大量相同的几何体
        // 相比创建多个Mesh，InstancedMesh只需要一次绘制调用

        const instanceCount = 1000;  // 实例数量

        // 创建基础几何体
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.5,
            metalness: 0.3
        });

        // 创建InstancedMesh
        const instancedMesh = new THREE.InstancedMesh(geometry, material, instanceCount);
        scene.add(instancedMesh);

        // 创建临时对象用于计算变换矩阵
        const dummy = new THREE.Object3D();
        const matrix = new THREE.Matrix4();
        const color = new THREE.Color();

        // 为每个实例设置变换矩阵和颜色
        for (let i = 0; i < instanceCount; i++) {
            // 随机位置（在20x20的区域内）
            dummy.position.set(
                (Math.random() - 0.5) * 20,
                0.5 + Math.random() * 2,
                (Math.random() - 0.5) * 20
            );

            // 随机旋转
            dummy.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            // 随机缩放
            const scale = 0.5 + Math.random() * 1.5;
            dummy.scale.set(scale, scale, scale);

            // 更新矩阵
            dummy.updateMatrix();

            // 设置实例的变换矩阵
            instancedMesh.setMatrixAt(i, dummy.matrix);

            // 设置实例的颜色
            color.setHSL(Math.random(), 0.7, 0.5);
            instancedMesh.setColorAt(i, color);
        }

        // 标记矩阵和颜色需要更新
        instancedMesh.instanceMatrix.needsUpdate = true;
        instancedMesh.instanceColor.needsUpdate = true;

        // 更新统计信息
        document.getElementById('count').textContent = instanceCount;

        // FPS计算
        let frameCount = 0;
        let lastTime = performance.now();

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            // 计算FPS
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }

            // 让相机围绕场景旋转
            const time = Date.now() * 0.0003;
            camera.position.x = Math.sin(time) * 25;
            camera.position.z = Math.cos(time) * 25;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        animate();

        // 响应式窗口调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>示例3：自定义BufferGeometry</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background-color: #000;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">示例3：自定义BufferGeometry - 手动创建顶点、索引、法线、UV和颜色</div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // 创建场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        // 创建相机
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 3, 6);
        camera.lookAt(0, 0, 0);

        // 创建渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // 创建网格辅助线
        const gridHelper = new THREE.GridHelper(10, 10);
        scene.add(gridHelper);

        // 创建自定义BufferGeometry
        const geometry = new THREE.BufferGeometry();

        // 1. 定义顶点位置（每个顶点3个值：x, y, z）
        // 创建一个金字塔形状
        const vertices = new Float32Array([
            // 底面（4个顶点）
            -1, 0, -1,  // 顶点0
             1, 0, -1,  // 顶点1
             1, 0,  1,  // 顶点2
            -1, 0,  1,  // 顶点3
            // 顶点（1个顶点）
             0, 2,  0   // 顶点4
        ]);

        // 添加位置属性到几何体
        // 参数：属性名称、属性值、每个顶点的分量数（3表示x,y,z）
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

        // 2. 定义索引（定义三角形）
        // 索引数组指定哪些顶点组成三角形
        const indices = new Uint16Array([
            // 底面（2个三角形）
            0, 1, 2,  // 三角形1
            0, 2, 3,  // 三角形2
            // 侧面（4个三角形）
            0, 4, 1,  // 前面
            1, 4, 2,  // 右面
            2, 4, 3,  // 后面
            3, 4, 0   // 左面
        ]);

        // 设置索引
        geometry.setIndex(new THREE.BufferAttribute(indices, 1));

        // 3. 计算法线（用于光照）
        // 法线是垂直于面的向量，决定光照如何反射
        geometry.computeVertexNormals();

        // 4. 定义UV坐标（用于纹理映射）
        // UV坐标范围从0到1，(0,0)在左下角，(1,1)在右上角
        const uvs = new Float32Array([
            // 底面UV
            0, 0,  // 顶点0
            1, 0,  // 顶点1
            1, 1,  // 顶点2
            0, 1,  // 顶点3
            // 顶点UV
            0.5, 0.5  // 顶点4
        ]);

        // 添加UV属性
        geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

        // 5. 定义顶点颜色（每个顶点3个值：r, g, b）
        const colors = new Float32Array([
            // 底面颜色（渐变）
            1, 0, 0,  // 顶点0 - 红色
            0, 1, 0,  // 顶点1 - 绿色
            0, 0, 1,  // 顶点2 - 蓝色
            1, 1, 0,  // 顶点3 - 黄色
            // 顶点颜色
            1, 0, 1   // 顶点4 - 紫色
        ]);

        // 添加颜色属性
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // 创建材质（启用顶点颜色）
        const material = new THREE.MeshStandardMaterial({
            vertexColors: true,  // 启用顶点颜色
            roughness: 0.5,
            metalness: 0.3,
            side: THREE.DoubleSide  // 渲染双面
        });

        // 创建网格
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 0.5;
        scene.add(mesh);

        // 创建线框版本（显示三角形结构）
        const wireframeGeometry = new THREE.WireframeGeometry(geometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
        const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
        wireframe.position.y = 0.5;
        scene.add(wireframe);

        // 添加坐标轴辅助线
        const axesHelper = new THREE.AxesHelper(2);
        axesHelper.position.y = 0.5;
        scene.add(axesHelper);

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            // 旋转金字塔
            mesh.rotation.y += 0.01;
            wireframe.rotation.y += 0.01;
            axesHelper.rotation.y += 0.01;

            // 上下浮动
            const time = Date.now() * 0.001;
            mesh.position.y = 0.5 + Math.sin(time) * 0.3;
            wireframe.position.y = 0.5 + Math.sin(time) * 0.3;
            axesHelper.position.y = 0.5 + Math.sin(time) * 0.3;

            renderer.render(scene, camera);
        }

        animate();

        // 响应式窗口调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 着色器材质示例</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 350px;
        }
        #info h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #4CAF50;
        }
        #info p {
            margin: 5px 0;
            line-height: 1.5;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            width: 280px;
        }
        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #4CAF50;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .material-label {
            position: absolute;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 4px;
            pointer-events: none;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>着色器材质示例</h2>
        <p>展示自定义GLSL着色器</p>
        <p>从左到右：</p>
        <p>1. 波动效果 - 顶点动画</p>
        <p>2. 渐变效果 - 片段着色</p>
        <p>3. 条纹效果 - UV坐标</p>
        <p>4. 噪声效果 - 噪声函数</p>
        <p>5. 全息效果 - 菲涅尔</p>
    </div>

    <div id="controls">
        <h3>着色器控制</h3>
        <div class="control-group">
            <label>时间速度 (Time Speed): <span id="timeSpeedValue">1.0</span></label>
            <input type="range" id="timeSpeed" min="0" max="3" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>波动强度 (Wave Intensity): <span id="waveIntensityValue">0.5</span></label>
            <input type="range" id="waveIntensity" min="0" max="2" step="0.1" value="0.5">
        </div>
        <div class="control-group">
            <label>颜色强度 (Color Intensity): <span id="colorIntensityValue">1.0</span></label>
            <input type="range" id="colorIntensity" min="0" max="2" step="0.1" value="1.0">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // 导入Three.js核心库和轨道控制器
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // 全局变量声明
        let scene, camera, renderer, controls;  // 场景、相机、渲染器、控制器
        let spheres = [];  // 存储所有球体网格对象
        let clock = new THREE.Clock();  // 时钟对象，用于计算时间增量

        /**
         * 初始化函数
         * 创建场景、相机、渲染器等基础组件
         */
        function init() {
            // 创建容器div并添加到body
            const container = document.createElement('div');
            document.body.appendChild(container);

            // 创建场景对象
            scene = new THREE.Scene();
            // 设置场景背景颜色为深灰色
            scene.background = new THREE.Color(0x222222);

            // 创建透视相机
            // 参数: 视野角度(60度), 宽高比, 近裁剪面(0.1), 远裁剪面(1000)
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            // 设置相机位置
            camera.position.set(0, 4, 10);

            // 创建WebGL渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });  // 开启抗锯齿
            renderer.setSize(window.innerWidth, window.innerHeight);  // 设置渲染尺寸
            renderer.setPixelRatio(window.devicePixelRatio);  // 设置像素比，适配高清屏
            renderer.shadowMap.enabled = true;  // 启用阴影映射
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // 使用柔和阴影
            container.appendChild(renderer.domElement);  // 将渲染器添加到容器

            // 创建轨道控制器
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;  // 启用阻尼效果，使旋转更平滑
            controls.dampingFactor = 0.05;  // 阻尼系数

            // 添加光源
            addLights();
            // 创建着色器材质
            createMaterials();
            // 创建地面
            createFloor();
            // 创建标签
            createLabels();
            // 设置控制器
            setupControls();

            // 监听窗口大小变化
            window.addEventListener('resize', onWindowResize);
            // 开始动画循环
            animate();
        }

        /**
         * 添加光源
         * 创建环境光和平行光
         */
        function addLights() {
            // 创建环境光 - 提供基础照明
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // 创建平行光 - 模拟太阳光
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7);  // 设置光源位置
            scene.add(directionalLight);
        }

        /**
         * 创建着色器材质球体
         * 展示各种自定义GLSL着色器效果
         */
        function createMaterials() {
            // 创建球体几何体 - 使用高分段数以获得更平滑的表面
            // 参数: 半径(0.7), 水平分段数(64), 垂直分段数(64)
            const geometry = new THREE.SphereGeometry(0.7, 64, 64);

            // 定义5种着色器材质及其配置
            const materials = [
                {
                    name: '波动效果',
                    material: createWaveMaterial(),  // 波动效果着色器
                    position: { x: -4, y: 1, z: 0 }
                },
                {
                    name: '渐变效果',
                    material: createGradientMaterial(),  // 渐变效果着色器
                    position: { x: -2, y: 1, z: 0 }
                },
                {
                    name: '条纹效果',
                    material: createStripeMaterial(),  // 条纹效果着色器
                    position: { x: 0, y: 1, z: 0 }
                },
                {
                    name: '噪声效果',
                    material: createNoiseMaterial(),  // 噪声效果着色器
                    position: { x: 2, y: 1, z: 0 }
                },
                {
                    name: '全息效果',
                    material: createHologramMaterial(),  // 全息效果着色器
                    position: { x: 4, y: 1, z: 0 }
                }
            ];

            // 遍历材质数组，创建球体网格
            materials.forEach((item, index) => {
                const sphere = new THREE.Mesh(geometry, item.material);
                sphere.position.set(item.position.x, item.position.y, item.position.z);
                sphere.castShadow = true;  // 投射阴影
                sphere.receiveShadow = true;  // 接收阴影
                sphere.userData.name = item.name;  // 存储材质名称
                scene.add(sphere);
                spheres.push(sphere);  // 添加到球体数组
            });
        }

        /**
         * 创建波动效果着色器材质
         * 使用顶点着色器实现表面波动动画
         */
        function createWaveMaterial() {
            return new THREE.ShaderMaterial({
                // Uniforms - 从JavaScript传递到着色器的变量
                uniforms: {
                    time: { value: 0 },  // 时间变量，用于动画
                    color: { value: new THREE.Color(0xff0000) },  // 基础颜色
                    waveIntensity: { value: 0.5 }  // 波动强度
                },
                // 顶点着色器 - 处理顶点位置和属性
                vertexShader: `
                    // Uniform声明 - 从JavaScript传入的变量
                    uniform float time;  // 时间
                    uniform float waveIntensity;  // 波动强度

                    // Varying声明 - 从顶点着色器传递到片段着色器的变量
                    varying vec2 vUv;  // UV坐标
                    varying vec3 vNormal;  // 法线向量
                    varying vec3 vPosition;  // 顶点位置

                    void main() {
                        // 传递UV坐标和法线到片段着色器
                        vUv = uv;
                        vNormal = normal;
                        vPosition = position;

                        // 创建顶点位置的副本
                        vec3 pos = position;

                        // 沿法线方向添加波动效果
                        // 使用正弦函数在X、Y、Z三个方向上创建波动
                        // sin(频率 * 坐标 + 时间) * 强度
                        pos += normal * sin(pos.x * 10.0 + time) * waveIntensity * 0.1;
                        pos += normal * sin(pos.y * 10.0 + time * 1.5) * waveIntensity * 0.1;
                        pos += normal * sin(pos.z * 10.0 + time * 2.0) * waveIntensity * 0.1;

                        // 计算最终的顶点位置
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                // 片段着色器 - 处理像素颜色
                fragmentShader: `
                    // Uniform声明
                    uniform vec3 color;  // 基础颜色
                    uniform float time;  // 时间

                    // Varying声明 - 从顶点着色器接收的变量
                    varying vec2 vUv;  // UV坐标
                    varying vec3 vNormal;  // 法线向量
                    varying vec3 vPosition;  // 顶点位置

                    void main() {
                        // 计算法线与视角的点积，用于光照强度
                        float intensity = dot(vNormal, vec3(0.0, 0.0, 1.0));

                        // 根据光照强度调整颜色
                        vec3 finalColor = color * (0.5 + 0.5 * intensity);

                        // 添加基于位置的波动颜色变化
                        finalColor += sin(vPosition.y * 10.0 + time) * 0.1;

                        // 输出最终颜色
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide  // 双面渲染
            });
        }

        /**
         * 创建渐变效果着色器材质
         * 使用片段着色器实现颜色渐变
         */
        function createGradientMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },  // 时间变量
                    colorIntensity: { value: 1.0 }  // 颜色强度
                },
                vertexShader: `
                    // Varying声明 - 传递UV坐标和位置到片段着色器
                    varying vec2 vUv;
                    varying vec3 vPosition;

                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;  // 时间
                    uniform float colorIntensity;  // 颜色强度
                    varying vec2 vUv;  // UV坐标
                    varying vec3 vPosition;  // 顶点位置

                    void main() {
                        // 定义三个基础颜色
                        vec3 color1 = vec3(1.0, 0.0, 0.0);  // 红色
                        vec3 color2 = vec3(0.0, 1.0, 0.0);  // 绿色
                        vec3 color3 = vec3(0.0, 0.0, 1.0);  // 蓝色

                        // 基于Y位置和时间计算混合因子
                        float t = sin(vPosition.y * 2.0 + time) * 0.5 + 0.5;

                        // 使用mix函数在颜色之间进行线性插值
                        vec3 color = mix(color1, color2, t);  // 红色和绿色混合
                        color = mix(color, color3, vUv.x);  // 再与蓝色混合，基于UV的X坐标

                        // 应用颜色强度
                        gl_FragColor = vec4(color * colorIntensity, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
        }

        /**
         * 创建条纹效果着色器材质
         * 使用UV坐标创建条纹图案
         */
        function createStripeMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },  // 时间变量
                    colorIntensity: { value: 1.0 }  // 颜色强度
                },
                vertexShader: `
                    varying vec2 vUv;  // UV坐标
                    varying vec3 vPosition;  // 顶点位置

                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;  // 时间
                    uniform float colorIntensity;  // 颜色强度
                    varying vec2 vUv;  // UV坐标
                    varying vec3 vPosition;  // 顶点位置

                    void main() {
                        // 基于UV的X坐标创建条纹
                        // sin函数创建周期性变化
                        float stripe = sin(vUv.x * 20.0 + time * 2.0);

                        // step函数将连续值转换为二进制值（0或1）
                        // 大于0返回1，小于等于0返回0
                        stripe = step(0.0, stripe);

                        // 定义两种颜色
                        vec3 color1 = vec3(1.0, 1.0, 1.0);  // 白色
                        vec3 color2 = vec3(0.0, 0.0, 0.0);  // 黑色

                        // 根据stripe值混合颜色
                        vec3 color = mix(color1, color2, stripe);

                        // 应用颜色强度
                        color *= colorIntensity;

                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
        }

        /**
         * 创建噪声效果着色器材质
         * 实现Perlin噪声算法
         */
        function createNoiseMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },  // 时间变量
                    colorIntensity: { value: 1.0 }  // 颜色强度
                },
                vertexShader: `
                    varying vec2 vUv;  // UV坐标
                    varying vec3 vPosition;  // 顶点位置

                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;  // 时间
                    uniform float colorIntensity;  // 颜色强度
                    varying vec2 vUv;  // UV坐标
                    varying vec3 vPosition;  // 顶点位置

                    // 伪随机数生成函数
                    // 使用正弦函数和点积生成看似随机的值
                    float random(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                    }

                    // 2D噪声函数（Perlin噪声的简化版本）
                    float noise(vec2 st) {
                        // 获取整数部分和小数部分
                        vec2 i = floor(st);  // 整数坐标
                        vec2 f = fract(st);  // 小数坐标

                        // 获取四个角的随机值
                        float a = random(i);
                        float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0));
                        float d = random(i + vec2(1.0, 1.0));

                        // 平滑插值函数 - 使过渡更平滑
                        vec2 u = f * f * (3.0 - 2.0 * f);

                        // 双线性插值
                        return mix(a, b, u.x) +
                               (c - a) * u.y * (1.0 - u.x) +
                               (d - b) * u.x * u.y;
                    }

                    void main() {
                        // 计算噪声值，基于位置和时间
                        float n = noise(vPosition.xy * 5.0 + time);

                        // 根据噪声值创建颜色
                        // 红色通道使用噪声值，绿色和蓝色使用衰减值
                        vec3 color = vec3(n, n * 0.5, n * 0.2);

                        // 应用颜色强度
                        color *= colorIntensity;

                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
        }

        /**
         * 创建全息效果着色器材质
         * 使用菲涅尔效应实现全息效果
         */
        function createHologramMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },  // 时间变量
                    viewVector: { value: new THREE.Vector3() },  // 视线向量
                    colorIntensity: { value: 1.0 }  // 颜色强度
                },
                vertexShader: `
                    uniform vec3 viewVector;  // 视线向量
                    varying float vIntensity;  // 菲涅尔强度
                    varying vec2 vUv;  // UV坐标

                    void main() {
                        vUv = uv;

                        // 将法线转换到视图空间
                        vec3 vNormal = normalize(normalMatrix * normal);

                        // 将视线向量转换到视图空间
                        vec3 vNormel = normalize(normalMatrix * viewVector);

                        // 计算菲涅尔效应
                        // 当视线与表面法线垂直时，强度最大
                        vIntensity = pow(0.7 - dot(vNormal, vNormel), 2.0);

                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;  // 时间
                    uniform float colorIntensity;  // 颜色强度
                    varying float vIntensity;  // 菲涅尔强度
                    varying vec2 vUv;  // UV坐标

                    void main() {
                        // 创建扫描线效果
                        float scanline = sin(vUv.y * 100.0 + time * 5.0) * 0.5 + 0.5;

                        // 定义全息颜色（青色）
                        vec3 color = vec3(0.0, 1.0, 1.0);

                        // 组合菲涅尔强度、扫描线和颜色强度
                        color *= vIntensity * scanline * colorIntensity;

                        // 使用菲涅尔强度作为透明度
                        gl_FragColor = vec4(color, vIntensity * 0.8);
                    }
                `,
                side: THREE.DoubleSide,
                transparent: true,  // 启用透明度
                blending: THREE.AdditiveBlending  // 使用加法混合模式
            });
        }

        /**
         * 创建地面
         * 创建接收阴影的地面和网格辅助线
         */
        function createFloor() {
            // 创建平面几何体
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            // 创建标准材质
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,  // 深灰色
                roughness: 0.8,  // 粗糙度
                metalness: 0.2  // 金属度
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;  // 旋转90度使其水平
            floor.position.y = 0;  // 设置地面高度
            floor.receiveShadow = true;  // 接收阴影
            scene.add(floor);

            // 创建网格辅助线
            const gridHelper = new THREE.GridHelper(20, 20, 0x666666, 0x555555);
            gridHelper.position.y = 0.01;  // 稍微抬高避免z-fighting
            scene.add(gridHelper);
        }

        /**
         * 创建标签
         * 为每个球体创建HTML标签显示材质名称
         */
        function createLabels() {
            // 定义标签内容
            const labels = [
                { text: '波动\n顶点动画', position: { x: -4, y: 2.5, z: 0 } },
                { text: '渐变\n片段着色', position: { x: -2, y: 2.5, z: 0 } },
                { text: '条纹\nUV坐标', position: { x: 0, y: 2.5, z: 0 } },
                { text: '噪声\n噪声函数', position: { x: 2, y: 2.5, z: 0 } },
                { text: '全息\n菲涅尔', position: { x: 4, y: 2.5, z: 0 } }
            ];

            // 为每个标签创建div元素
            labels.forEach(label => {
                const div = document.createElement('div');
                div.className = 'material-label';
                div.innerHTML = label.text;
                div.style.left = '50%';
                div.style.top = '50%';
                div.style.transform = 'translate(-50%, -50%)';
                div.style.whiteSpace = 'pre-line';  // 保留换行符
                div.style.textAlign = 'center';
                div.style.lineHeight = '1.3';
                document.body.appendChild(div);
                label.element = div;  // 保存div引用
            });

            // 将标签数组存储到window对象，便于后续更新
            window.materialLabels = labels;
        }

        /**
         * 更新标签位置
         * 将3D坐标转换为2D屏幕坐标
         */
        function updateLabels() {
            if (!window.materialLabels) return;

            // 遍历所有标签
            window.materialLabels.forEach(label => {
                // 将3D位置转换为向量
                const vector = new THREE.Vector3(label.position.x, label.position.y, label.position.z);
                // 投影到标准化设备坐标(NDC)
                vector.project(camera);

                // 将NDC坐标转换为屏幕像素坐标
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;

                // 只显示在相机视野内的标签
                if (vector.z < 1) {
                    label.element.style.display = 'block';
                    label.element.style.left = `${x}px`;
                    label.element.style.top = `${y}px`;
                } else {
                    label.element.style.display = 'none';
                }
            });
        }

        /**
         * 设置控制器
         * 为滑块添加事件监听器
         */
        function setupControls() {
            const timeSpeedSlider = document.getElementById('timeSpeed');
            const waveIntensitySlider = document.getElementById('waveIntensity');
            const colorIntensitySlider = document.getElementById('colorIntensity');

            const timeSpeedValue = document.getElementById('timeSpeedValue');
            const waveIntensityValue = document.getElementById('waveIntensityValue');
            const colorIntensityValue = document.getElementById('colorIntensityValue');

            // 时间速度滑块
            timeSpeedSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                timeSpeedValue.textContent = value.toFixed(1);
            });

            // 波动强度滑块 - 更新第一个球体的波动强度
            waveIntensitySlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                waveIntensityValue.textContent = value.toFixed(1);
                spheres[0].material.uniforms.waveIntensity.value = value;
            });

            // 颜色强度滑块 - 更新所有着色器的颜色强度
            colorIntensitySlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                colorIntensityValue.textContent = value.toFixed(1);
                spheres.forEach(sphere => {
                    if (sphere.material.uniforms.colorIntensity) {
                        sphere.material.uniforms.colorIntensity.value = value;
                    }
                });
            });
        }

        /**
         * 窗口大小变化处理
         * 更新相机和渲染器参数
         */
        function onWindowResize() {
            // 更新相机宽高比
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            // 更新渲染器尺寸
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * 动画循环
         * 每帧更新场景并渲染
         */
        function animate() {
            requestAnimationFrame(animate);  // 请求下一帧

            // 获取经过的时间（秒）
            const time = clock.getElapsedTime();
            // 获取时间速度
            const timeSpeed = parseFloat(document.getElementById('timeSpeed').value);

            // 更新每个球体的位置、旋转和着色器uniforms
            spheres.forEach((sphere, index) => {
                // 上下浮动动画 - 每个球体有相位差
                sphere.position.y = 1 + Math.sin(time * timeSpeed + index * 0.5) * 0.2;
                // 旋转动画
                sphere.rotation.y = time * 0.3;

                // 更新着色器的time uniform
                if (sphere.material.uniforms.time) {
                    sphere.material.uniforms.time.value = time * timeSpeed;
                }

                // 更新全息着色器的viewVector uniform
                if (sphere.material.uniforms.viewVector) {
                    sphere.material.uniforms.viewVector.value = new THREE.Vector3().subVectors(
                        camera.position,
                        sphere.position
                    );
                }
            });

            // 更新控制器
            controls.update();
            // 更新标签位置
            updateLabels();
            // 渲染场景
            renderer.render(scene, camera);
        }

        // 启动程序
        init();
    </script>
</body>
</html>
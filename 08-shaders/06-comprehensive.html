<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>综合示例 - Three.js Shaders教程</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 5px;
      max-width: 350px;
    }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 5px;
      max-width: 280px;
    }
    #controls label {
      display: block;
      margin: 10px 0 5px 0;
    }
    #controls input[type="range"] {
      width: 100%;
    }
    #controls button {
      width: 100%;
      padding: 8px;
      margin-top: 10px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #controls button:hover {
      background: #45a049;
    }
  </style>
</head>
<body>
  <div id="info">
    <h3>综合示例</h3>
    <p>多种着色器技术的组合</p>
    <p style="font-size: 12px; margin-top: 10px;">
      • Fresnel边缘发光<br>
      • 顶点位移动画<br>
      • 噪声纹理<br>
      • 动态颜色渐变<br>
      • 光照计算
    </p>
  </div>
  <div id="controls">
    <h3>控制面板</h3>
    <label>Fresnel强度: <span id="fresnel-value">3.0</span></label>
    <input type="range" id="fresnel-slider" min="1" max="10" step="0.5" value="3">
    <label>波动振幅: <span id="amplitude-value">0.2</span></label>
    <input type="range" id="amplitude-slider" min="0" max="0.5" step="0.02" value="0.2">
    <label>波动频率: <span id="frequency-value">3.0</span></label>
    <input type="range" id="frequency-slider" min="1" max="10" step="0.5" value="3">
    <label>动画速度: <span id="speed-value">1.0</span></label>
    <input type="range" id="speed-slider" min="0" max="3" step="0.1" value="1">
    <label>噪声强度: <span id="noise-value">0.3</span></label>
    <input type="range" id="noise-slider" min="0" max="1" step="0.05" value="0.3">
    <button id="reset-btn">重置参数</button>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls;
    let clock;
    let shaderMaterial;

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x333333);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 3, 7);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      clock = new THREE.Clock();

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 10, 7);
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0x667eea, 0.5, 10);
      pointLight.position.set(-3, 2, 3);
      scene.add(pointLight);

      const gridHelper = new THREE.GridHelper(10, 10, 0x888888, 0x444444);
      scene.add(gridHelper);

      createComprehensiveShader();

      setupControls();

      window.addEventListener('resize', onWindowResize);
    }

    function createComprehensiveShader() {
      const vertexShader = `
        uniform float time;
        uniform float amplitude;
        uniform float frequency;
        uniform float noiseStrength;

        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying vec3 vViewPosition;
        varying float vElevation;

        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        float noise(vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        void main() {
          vUv = uv;
          vNormal = normalize(normalMatrix * normal);
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;

          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          vViewPosition = mvPosition.xyz;

          vec3 pos = position;

          float wave1 = sin(pos.x * frequency + time) * amplitude;
          float wave2 = sin(pos.y * frequency + time) * amplitude;
          float wave3 = sin((pos.x + pos.y) * frequency * 0.5 + time * 1.5) * amplitude * 0.5;

          float n = noise(pos.xy * 2.0 + time * 0.5) * noiseStrength;

          pos.z += wave1 + wave2 + wave3 + n;
          vElevation = wave1 + wave2 + wave3;

          gl_Position = projectionMatrix * mvPosition;
        }
      `;

      const fragmentShader = `
        uniform float time;
        uniform float fresnelPower;
        uniform float noiseStrength;

        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying vec3 vViewPosition;
        varying float vElevation;

        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        float noise(vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        void main() {
          vec3 color1 = vec3(0.2, 0.4, 0.9);
          vec3 color2 = vec3(0.9, 0.2, 0.4);
          vec3 color3 = vec3(0.2, 0.9, 0.4);
          vec3 fresnelColor = vec3(0.4, 0.5, 1.0);

          float elevationFactor = (vElevation + 0.5) * 1.0;
          vec3 baseColor = mix(color1, color2, elevationFactor);

          float uvFactor = sin(vUv.x * 10.0 + time) * 0.5 + 0.5;
          baseColor = mix(baseColor, color3, uvFactor * 0.3);

          float n = noise(vUv * 5.0 + time * 0.3) * noiseStrength;
          baseColor += vec3(n * 0.3);

          vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
          float fresnel = pow(1.0 - dot(viewDirection, vNormal), fresnelPower);

          vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
          float lighting = max(dot(vNormal, lightDir), 0.0) * 0.6 + 0.4;

          vec3 finalColor = baseColor * lighting + fresnelColor * fresnel;

          gl_FragColor = vec4(finalColor, 1.0);
        }
      `;

      const uniforms = {
        time: { value: 0 },
        fresnelPower: { value: 3.0 },
        amplitude: { value: 0.2 },
        frequency: { value: 3.0 },
        noiseStrength: { value: 0.3 }
      };

      shaderMaterial = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader
      });

      const sphereGeometry = new THREE.SphereGeometry(1.5, 64, 64);
      const sphere = new THREE.Mesh(sphereGeometry, shaderMaterial);
      sphere.position.set(0, 1.5, 0);
      scene.add(sphere);

      const torusGeometry = new THREE.TorusGeometry(1, 0.4, 32, 100);
      const torus = new THREE.Mesh(torusGeometry, shaderMaterial.clone());
      torus.position.set(3, 1, 0);
      scene.add(torus);

      const boxGeometry = new THREE.BoxGeometry(2, 2, 2, 32, 32, 32);
      const box = new THREE.Mesh(boxGeometry, shaderMaterial.clone());
      box.position.set(-3, 1, 0);
      scene.add(box);

      const planeGeometry = new THREE.PlaneGeometry(4, 4, 64, 64);
      const plane = new THREE.Mesh(planeGeometry, shaderMaterial.clone());
      plane.rotation.x = -Math.PI / 2;
      plane.position.set(0, 0.1, 0);
      scene.add(plane);
    }

    function setupControls() {
      const fresnelSlider = document.getElementById('fresnel-slider');
      const amplitudeSlider = document.getElementById('amplitude-slider');
      const frequencySlider = document.getElementById('frequency-slider');
      const speedSlider = document.getElementById('speed-slider');
      const noiseSlider = document.getElementById('noise-slider');
      const resetBtn = document.getElementById('reset-btn');

      fresnelSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        document.getElementById('fresnel-value').textContent = value.toFixed(1);
        updateUniform('fresnelPower', value);
      });

      amplitudeSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        document.getElementById('amplitude-value').textContent = value.toFixed(2);
        updateUniform('amplitude', value);
      });

      frequencySlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        document.getElementById('frequency-value').textContent = value.toFixed(1);
        updateUniform('frequency', value);
      });

      noiseSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        document.getElementById('noise-value').textContent = value.toFixed(2);
        updateUniform('noiseStrength', value);
      });

      resetBtn.addEventListener('click', () => {
        document.getElementById('fresnel-slider').value = 3;
        document.getElementById('amplitude-slider').value = 0.2;
        document.getElementById('frequency-slider').value = 3;
        document.getElementById('speed-slider').value = 1;
        document.getElementById('noise-slider').value = 0.3;

        document.getElementById('fresnel-value').textContent = '3.0';
        document.getElementById('amplitude-value').textContent = '0.20';
        document.getElementById('frequency-value').textContent = '3.0';
        document.getElementById('speed-value').textContent = '1.0';
        document.getElementById('noise-value').textContent = '0.30';

        updateUniform('fresnelPower', 3.0);
        updateUniform('amplitude', 0.2);
        updateUniform('frequency', 3.0);
        updateUniform('noiseStrength', 0.3);
      });
    }

    function updateUniform(name, value) {
      scene.traverse((object) => {
        if (object.isMesh && object.material.uniforms) {
          object.material.uniforms[name].value = value;
        }
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      const time = clock.getElapsedTime();
      const speed = parseFloat(document.getElementById('speed-slider').value);

      scene.traverse((object) => {
        if (object.isMesh && object.material.uniforms) {
          object.material.uniforms.time.value = time * speed;
        }
      });

      controls.update();
      renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html>
